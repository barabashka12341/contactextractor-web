const express = require('express');
const cors = require('cors');
const path = require('path');
const axios = require('axios');
const cheerio = require('cheerio');

const app = express();
const PORT = process.env.PORT || 3100;
const HOST = process.env.HOST || '0.0.0.0';

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Store for active jobs
const activeJobs = new Map();

// Multiple user agents for rotation
const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
];

// Get random user agent
function getRandomUserAgent() {
  return userAgents[Math.floor(Math.random() * userAgents.length)];
}

// Enhanced email extraction with multiple strategies
async function extractEmailsFromUrl(url, retryCount = 0) {
  const maxRetries = 2;
  
  try {
    console.log(`üîç [–ü–æ–ø—ã—Ç–∫–∞ ${retryCount + 1}] –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–Ω—Ç–∞–∫—Ç—ã —Å: ${url}`);
    
    // Normalize URL
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url;
    }
    
    // Try different strategies
    const strategies = [
      // Strategy 1: Standard request
      async () => {
        const response = await axios.get(url, {
          timeout: 20000,
          headers: {
            'User-Agent': getRandomUserAgent(),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
            'Cache-Control': 'max-age=0'
          },
          maxRedirects: 5,
          validateStatus: function (status) {
            return status >= 200 && status < 400;
          }
        });
        return response.data;
      },
      
      // Strategy 2: Request without some headers
      async () => {
        const response = await axios.get(url, {
          timeout: 15000,
          headers: {
            'User-Agent': getRandomUserAgent(),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
          },
          maxRedirects: 3
        });
        return response.data;
      },
      
      // Strategy 3: Minimal headers
      async () => {
        const response = await axios.get(url, {
          timeout: 10000,
          headers: {
            'User-Agent': getRandomUserAgent()
          }
        });
        return response.data;
      }
    ];
    
    let html = '';
    let strategyUsed = 0;
    
    // Try each strategy until one works
    for (let i = 0; i < strategies.length; i++) {
      try {
        console.log(`üîÑ –°—Ç—Ä–∞—Ç–µ–≥–∏—è ${i + 1} –¥–ª—è ${url}`);
        html = await strategies[i]();
        strategyUsed = i + 1;
        break;
      } catch (error) {
        console.log(`‚ùå –°—Ç—Ä–∞—Ç–µ–≥–∏—è ${i + 1} –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞: ${error.message}`);
        if (i === strategies.length - 1) throw error;
      }
    }
    
    if (!html) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã');
    }
    
    const $ = cheerio.load(html);
    const emails = [];
    
    // Enhanced email regex
    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
    
    // Strategy 1: Search in all text content
    $('*').each((i, element) => {
      const text = $(element).text();
      if (text && text.length > 0) {
        const matches = text.match(emailRegex);
        if (matches) {
          emails.push(...matches);
        }
      }
    });
    
    // Strategy 2: Search in href attributes
    $('a[href^="mailto:"]').each((i, element) => {
      const href = $(element).attr('href');
      if (href) {
        const email = href.replace('mailto:', '').trim();
        if (email.match(emailRegex)) {
          emails.push(email);
        }
      }
    });
    
    // Strategy 3: Search in data attributes
    $('[data-email], [data-mail]').each((i, element) => {
      const email = $(element).attr('data-email') || $(element).attr('data-mail');
      if (email && email.match(emailRegex)) {
        emails.push(email);
      }
    });
    
    // Strategy 4: Search in title and meta tags
    $('title, meta[name="description"], meta[property="og:description"]').each((i, element) => {
      const text = $(element).text() || $(element).attr('content');
      if (text) {
        const matches = text.match(emailRegex);
        if (matches) {
          emails.push(...matches);
        }
      }
    });
    
    // Clean and filter emails
    const uniqueEmails = [...new Set(emails)]
      .filter(email => {
        return email && 
               email.length > 5 && 
               email.length < 100 &&
               !email.includes('example.com') && 
               !email.includes('test.com') && 
               !email.includes('domain.com') &&
               !email.includes('localhost') &&
               !email.includes('127.0.0.1') &&
               email.includes('@') &&
               email.split('@')[1].includes('.');
      })
      .map(email => email.toLowerCase().trim());
    
    console.log(`‚úÖ –°—Ç—Ä–∞—Ç–µ–≥–∏—è ${strategyUsed}: –ù–∞–π–¥–µ–Ω–æ ${uniqueEmails.length} email –∞–¥—Ä–µ—Å–æ–≤ –Ω–∞ ${url}`);
    return uniqueEmails;
    
  } catch (error) {
    console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ —Å ${url}:`, error.message);
    
    // Retry with different approach
    if (retryCount < maxRetries) {
      console.log(`üîÑ –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ ${retryCount + 1}/${maxRetries} –¥–ª—è ${url}`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (retryCount + 1))); // Progressive delay
      return extractEmailsFromUrl(url, retryCount + 1);
    }
    
    return [];
  }
}

// API Routes
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.post('/api/extract', async (req, res) => {
  try {
    const { urls } = req.body;
    if (!urls || urls.length === 0) {
      return res.status(400).json({ error: 'URLs are required' });
    }

    // Limit to 5 URLs to prevent overload
    const limitedUrls = urls.slice(0, 5);
    
    const jobId = Date.now().toString();
    activeJobs.set(jobId, {
      id: jobId,
      status: 'running',
      startTime: new Date(),
      urls: limitedUrls,
      results: [],
      processed: 0,
      total: limitedUrls.length
    });

    // Process URLs in background with better error handling
    (async () => {
      const allEmails = [];
      let processedCount = 0;
      let successCount = 0;
      
      for (const url of limitedUrls) {
        try {
          console.log(`üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º ${processedCount + 1}/${limitedUrls.length}: ${url}`);
          
          const emails = await extractEmailsFromUrl(url);
          
          if (emails.length > 0) {
            allEmails.push(...emails.map(email => ({ url, email })));
            successCount++;
            console.log(`‚úÖ –£—Å–ø–µ—à–Ω–æ: ${url} - –Ω–∞–π–¥–µ–Ω–æ ${emails.length} email`);
          } else {
            console.log(`‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ email –Ω–∞ ${url}`);
          }
          
          processedCount++;
          
          // Update job progress
          const job = activeJobs.get(jobId);
          if (job) {
            job.processed = processedCount;
            job.results = allEmails;
          }
          
          // Small delay between requests to be respectful
          await new Promise(resolve => setTimeout(resolve, 500));
          
        } catch (error) {
          console.error(`‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ ${url}:`, error.message);
          processedCount++;
        }
      }

      const job = activeJobs.get(jobId);
      if (job) {
        job.status = 'completed';
        job.endTime = new Date();
        job.results = allEmails;
        job.successCount = successCount;
        console.log(`üéâ –ó–∞–≤–µ—Ä—à–µ–Ω–æ! –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: ${processedCount}/${limitedUrls.length}, –£—Å–ø–µ—à–Ω–æ: ${successCount}, –ù–∞–π–¥–µ–Ω–æ email: ${allEmails.length}`);
      }
    })();

    res.json({ 
      success: true, 
      jobId,
      message: `–û–±—Ä–∞–±–æ—Ç–∫–∞ ${limitedUrls.length} —Å–∞–π—Ç–æ–≤ –Ω–∞—á–∞—Ç–∞`,
      limited: urls.length > 5 ? `–û–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –¥–æ 5 —Å–∞–π—Ç–æ–≤ –∏–∑ ${urls.length}` : null
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/job/:jobId', (req, res) => {
  const { jobId } = req.params;
  const job = activeJobs.get(jobId);
  if (!job) return res.status(404).json({ error: 'Job not found' });
  
  res.json({
    ...job,
    progress: job.total > 0 ? Math.round((job.processed / job.total) * 100) : 0
  });
});

app.get('/api/job/:jobId/download', (req, res) => {
  const { jobId } = req.params;
  const job = activeJobs.get(jobId);
  if (!job || job.status !== 'completed') {
    return res.status(404).json({ error: 'Job not found or not completed' });
  }

  const csv = 'URL,Email\n' + job.results.map(r => `${r.url},${r.email}`).join('\n');
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', 'attachment; filename=contacts.csv');
  res.send(csv);
});

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    activeJobs: activeJobs.size,
    version: '2.0-robust'
  });
});

// Start server
app.listen(PORT, HOST, () => {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë                                                                   ‚ïë');
  console.log('‚ïë        üéØ CONTACT EXTRACTOR - –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø üéØ              ‚ïë');
  console.log('‚ïë                                                                   ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('');
  console.log(`üåç –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É: ${PORT}`);
  console.log(`üåê –î–æ—Å—Ç—É–ø–µ–Ω –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:${PORT}`);
  console.log('');
  console.log('üîß –£–ª—É—á—à–µ–Ω–∏—è:');
  console.log('  ‚úÖ –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è');
  console.log('  ‚úÖ –†–æ—Ç–∞—Ü–∏—è User-Agent');
  console.log('  ‚úÖ –ü–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π');
  console.log('  ‚úÖ –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è email');
  console.log('  ‚úÖ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞–≥—Ä—É–∑–∫–∏ (–º–∞–∫—Å. 5 —Å–∞–π—Ç–æ–≤)');
  console.log('  ‚úÖ –ü–æ–¥—Ä–æ–±–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ');
  console.log('');
  console.log('üì± –û—Ç–∫—Ä–æ–π—Ç–µ –±—Ä–∞—É–∑–µ—Ä –∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∞–¥—Ä–µ—Å—É');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
});

module.exports = app;
